    Этот код использует алгоритм бинарного поиска для эффективного решения этой задачи. 
Ключевая идея - разбить два массива на две части так, чтобы
все элементы в левой части меньше или равны всем элементам в правой части.

 int left = (k+1)/2;
left – это желаемое количество элементов в левой части объединенного массива. 
Если k нечетно, левая часть будет на один элемент больше правой.

 int low = 0, high = m;
     Инициализируем границы бинарного поиска. 
low и high задают диапазон возможных размеров левой части, которую мы берем из nums1.  
Так как m <= n, то левая часть всегда будет меньше m, а правая меньше n.

int mid1 = (low+high)/2;
     Вычисляем середину текущего диапазона поиска в nums1.
int mid2 = left - mid1;
    Вычисляем размер левой части, которую мы берем из nums2. 
     Поскольку общий размер левой части должен быть left, а mid1 взято из nums1, остаток берем из nums2.

*   l1: Самый правый элемент в левой части nums1.
*   l2: Самый правый элемент в левой части nums2.
*   r1: Самый левый элемент в правой части nums1.
*   r2: Самый левый элемент в правой части nums2.

  *   if(mid1<m)
        r1=nums1[mid1];
 Если mid1 находится в пределах nums1, устанавливаем r1.

  *   if(mid1-1>=0)
           l1=nums1[mid1-1];
Если mid1 - 1 находится в пределах nums1, устанавливаем l1.

*   if (l1<=r2 && l2<=r1)
Это ключевая проверка. Если *самый правый элемент левой части nums1 меньше или равен самому левому элементу правой части nums2* 
 И *самый правый элемент левой части nums2 меньше или равен самому левому элементу правой части nums1*, это означает, 
 что мы нашли правильное разбиение.

    *   if(k%2==1)
        return max(l1,l2);
Если общий размер k нечетный, то медиана - это просто самый большой элемент из левой части
        return ((max(l1,l2)+min(r1,r2))/2.0);
Если общий размер k четный, то 
медиана - это среднее арифметическое между самым большим элементом левой части 
(максимум из l1 и l2) и самым маленьким элементом правой части (минимум из r1 и r2).

*   else if (l1>r2)
           high = mid1 - 1;
Если условие правильного разбиения не выполнено, и l1 > r2, это означает, 
что нам нужно уменьшить размер левой части, взятой из nums1. Сдвигаем high влево.

*   else
           low = mid1 + 1;
Иначе, нам нужно увеличить размер левой части, взятой из nums1. Сдвигаем low вправо.




